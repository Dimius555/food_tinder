# Food tinder

Демо проект для реализации поведения похожее на переключение карточек как в приложении Tinder.


Для реализации демо проекта была выбрана Clean Architecture на основе пакета flutter_bloc в реализации на кубитах.

Приложение состоит из нескольких слоев:
- UI (сюда входят экраны и виджеты)
- Business logic (это слой который состоит из сервисов и кубитов)
- Repositories (слой состоящий лишь из репозиториев и их интерфейсов)
- Data (слой состоящий из моделей, локальной базы данных(в данном проекте не реализовано) и сетевого уровня)
- Config (слой конфигурации приложения)


Слой UI позволяеть строить пользовательский интерфейс используя кастомные виджеты, либо использовать заренее заготовленые виджеты из фреймворка flutter. В проекте реализовано два кастомных виджета: AppLoadingWidget (затемняет экран и показывает индикатор загрузки из нативного виджетя для iOS (пакет cupertino)) и SwipeCardWidget (кастомный виджет, который показывает карточку, которую мы будем свайпать, также в него передаются параметры title и description для отображения на экране пользователю). Также в проекте были использованы нативные виджеты из "коробки" и виджеты нативные для ios. 

Слой business logic реализован на основе пакета state managment - Bloc. Данный пакет был выбрат ввиду его нескольких преимуществ:
- самый распространенный и используемый пакет в комьюнити. Это являеться большим преимуществом, так как вероятность не решить какую-то проблему связанную с пакетом близка к нулю.
- пакет прост в использовании и не имеет большой нагрузки на систему.
- в данном случае bloc реализованый на кубитах имеет одно дополнительное преимущество в виде его использования мной. На основе кубитов (это не было показано в приложении, так как не встрелилась такая необходимость) я пришел к новой моделе его использования через создание глобальных и локальных кубитов.

Слой repositories преднозначен для управлением потока данных из/в сеть/БД. В текущем демо проекте DishesRepository являеться интерфейсом для класса DishesRepositoryImpl. Следуя принципам SOLID, я реализую инициализацию DishesRepositoryImpl путем объявления экземпляра класаа DishesRepository в service_locator.dart. Такое решение позволяет инкапсулировать внутрение методы класса DishesRepositoryImpl и разработчик будет иметь доступ исключительно к тем методам, что были объявлены в DishesRepository.

Слой Data представляет из себя набор конечных классов: Dish, DishesApi, ThemeStorage и т.д. Данный слой условно разбивается на несколько подслоев. Первый подслой - слой моделей. Тут я создаю модели объектов, с которыми далее я буду работать. В классах моделей могут быть реализованы дополнительные методы, такие как toJson, fromJson и т.д. Следующий подслой - api. API являеться сетевым уровнем приложения и в данном проекте у меня не было сетевых запросов, однако я симулировал их с помощью установки задержки в 1 сек. С этом слое реализуются сетевые запросы к различным удаленным серверам и сервисам (например, наш backend или firebase). Также в этом слое я выделяю дополнительный подслой - storages (а также может быть local_db, в демке он не был реализован за ненадобностью). В слое storages храняться различные конфигурационные ключики и значения для них. В этом демо я реализовал для примера хранение значения темы приложения (его переключение не было реализована ввиду отсутствия ТЗ, но для примера работы с этим подслоем я добавил этот код). 

Последний слой - Config. Этот слой содержит различные надстройки над приложением. В данной демке этот слой содержит настройки темы, а также цветов приложения. 

В итоге такая архитектура приложения позволяет масштабировать дальшейшее развитие приложения, так как каждый из слоев условно независимый. Если предположим в данной демке добавится профиль пользователя, изменение настроек приложения и данных пользователя, то в этом случае просто создаются новые экраны, которые не связаны с другими экранами; создаются соответсвующие кубиты, которые также не влияют на работу других кубитов; новые репозитории, которые соответствовали бы данным, с которыми они будут работать (UserRepository, AppSettingsRepository); и тоже самое касаеться слоя data.

P.S. также в приложении я старался использовать принципы KISS (keep it simple as possible), DRY (don't repeat yourself), DI (dependency injection), SOLID.